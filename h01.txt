#include<opencv.hpp>
#include<vector>
#include<omp.h>
#define X_FIRST 250
#define Y_FIRST 360
#define MAXVALUE 10000
#define MINVALUE -10000
using namespace cv;
struct Camfiles
{
	int CamIndex;
	int StripIndex;
	int PhotoIndex;
	int ImgIndex;
	char* filename;
};
struct CorresPoint
{
	double x1;
	double y1;
	double x2;
	double y2;
	double X;
	double Y;
	double Z;
	int row1;
	int col1;
	int row2;
	int col2;
	int index1;
	int index2;
	int indexi;
	int indexj;
	int value;
	int overlap;
	bool banned;
};
struct Ex_Elements
{
	double Xs;
	double Ys;
	double Zs;
	double fai;
	double omiga;
	double kappa;
	double f;
};
struct Camera
{
	double cellsize;
	double f;
	double xp;
	double yp;
	double k1,k2,k3;
	double p1,p2;
};
struct IpsOfOp
{
	int i;
	int j;
	int k;
};
void Interior_Orientation(Camfiles* camfile,CorresPoint** CorresCoordinate,int* MatchNum,int NumOfCam,int NumOfImage,Camera* cams,char** arr_Str1);
void Calculate_Matrix_R(CvMat* R,double fai,double omiga,double kappa);
void xyz2XYZ(CvMat* R,double x,double y,double z,double* X,double* Y,double* Z);
vector<int> Generate_and_Sort(double* arr_f,double xStep,double yStep,int whichFirst);
void Floyed(int* coGraph,int* coDistance,int NumOfImage);
bool FindIsland(int* coGraph,int* coDistance,int NumOfImage,int* Islandnote,int *pIslandNum);
void ObjectSpacePoint(int indexi,int indexj,int indexk,int value,int NumOfImage,CorresPoint** CorresCoordinate,int* MatchNum);
void Purify10000(CorresPoint** CorresCoordinate,int* MatchNum,int* RealMatchNum,int NumOfImage);
void main()
{
    omp_set_num_threads(8);
	int NumOfCam=5;
	int StripNum=24;
	int dhehe,fhehe;
	int ImageNumpStrip=31;
	Camera* cams=new Camera [NumOfCam];
	double *arr_f=new double [NumOfCam];
	char Interior_elementspath[1024];
	FILE* fpInterior;
	int suiyi1,suiyi2;
	for(int i=0;i<NumOfCam;i++)
	{
		sprintf(Interior_elementspath,"F:\\Data\\oblique\\TopDC5相机参数\\TOPDC5Cam%d_7_24.cam",i+1);
		fpInterior=fopen(Interior_elementspath,"r");
		fscanf(fpInterior,"机身NO:%d\n",&suiyi1);
		fscanf(fpInterior,"镜头NO:%d\n",&suiyi2);
		fscanf(fpInterior,"cellsize(mm):%lf\n",&cams[i].cellsize);
		fscanf(fpInterior,"f(mm):%lf\n",&cams[i].f);
		arr_f[i]=cams[i].f;
		fscanf(fpInterior,"像主点xp(mm):%lf\n",&cams[i].xp);
		fscanf(fpInterior,"像主点yp(mm):%lf\n",&cams[i].yp);
		fscanf(fpInterior,"像主点yp(mm):%lf\n",&cams[i].yp);
		fscanf(fpInterior,"K1:%lf\n",&cams[i].k1);
		fscanf(fpInterior,"K2:%lf\n",&cams[i].k2);
		fscanf(fpInterior,"K3:%lf\n",&cams[i].k3);
		fscanf(fpInterior,"P1:%lf\n",&cams[i].p1);
		fscanf(fpInterior,"P2:%lf\n",&cams[i].p2);
		fclose(fpInterior);
	}
	vector<int> Pts_ind=Generate_and_Sort(arr_f,600,900,Y_FIRST);
	int NumOfImage=Pts_ind.size();
	Camfiles* camfile=new Camfiles[NumOfImage];
	for(int i=0;i<NumOfImage;i++)
	{
		camfile[i].ImgIndex=Pts_ind[i];
	}
	CvPoint** MatchIndex=new CvPoint* [NumOfImage*NumOfImage];
	int* MatchNum=new int [NumOfImage*NumOfImage];
	int* RealMatchNum=new int [NumOfImage*NumOfImage];
	int* PureMatchNum=new int [NumOfImage*NumOfImage];
	CorresPoint** CorresCoordinate=new CorresPoint* [NumOfImage*NumOfImage]; 
	const char* Matchfilename="F:\\Data\\oblique\\matches.init.txt";

	FILE* fpMatch;
	fpMatch=fopen(Matchfilename,"r");
	int imgindex1,imgindex2;
	int smallindex,largeindex;
	int Corres_ptsnum;
	int ptindex1,ptindex2;
	int reci,recj;
	double ransac_threshold;
	bool flag=false;
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			MatchNum[i*NumOfImage+j]=0;
			RealMatchNum[i*NumOfImage+j]=0;
			CorresCoordinate[i*NumOfImage+j]=NULL;
			MatchIndex[i*NumOfImage+j]=NULL;
		}
	}
	while(!feof(fpMatch))
	{
		flag=false;
		fscanf(fpMatch,"%d%d",&imgindex1,&imgindex2);
		for(int i=0;i<NumOfImage-1;i++)
		{
			for(int j=i+1;j<NumOfImage;j++)
			{
				smallindex=MIN(camfile[i].ImgIndex,camfile[j].ImgIndex);
				largeindex=MAX(camfile[i].ImgIndex,camfile[j].ImgIndex);
				if(imgindex1==smallindex&&imgindex2==largeindex)
				{
					if(camfile[i].ImgIndex==smallindex)
					{
						reci=i;
						recj=j;
					}
					else 
					{
						reci=j;
						recj=i;
					}
					fscanf(fpMatch,"%d",&Corres_ptsnum);
					MatchIndex[reci*NumOfImage+recj]=new CvPoint [Corres_ptsnum];
					CorresCoordinate[reci*NumOfImage+recj]=new CorresPoint[Corres_ptsnum];
					MatchNum[reci*NumOfImage+recj]=Corres_ptsnum;
					for(int k=0;k<Corres_ptsnum;k++)
					{
						fscanf(fpMatch,"%d%d",&ptindex1,&ptindex2);
						MatchIndex[reci*NumOfImage+recj][k].x=ptindex1;
						MatchIndex[reci*NumOfImage+recj][k].y=ptindex2;
					}
					flag=true;
					break;
				}
			}
		}
		if(!flag)
		{
			fscanf(fpMatch,"%d",&Corres_ptsnum);
			for(int k=0;k<Corres_ptsnum;k++)
			{
				fscanf(fpMatch,"%d%d",&ptindex1,&ptindex2);
			}
		}
	}
	fclose(fpMatch);
	//显示匹配结果
/*	FILE* fpRelations;
	fpRelations=fopen("F:\\killkillkill3720\\MatchRelations.txt","w");
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			printf("%5d",MatchNum[i*NumOfImage+j]);
			fprintf(fpRelations,"%5d",MatchNum[i*NumOfImage+j]);
		}
		printf("\n");
		fprintf(fpRelations,"\n");
	}
	fclose(fpRelations);*/
	printf("匹配完了！\n");
	char** arr_Str1=new char* [NumOfImage];
	for(int i=0;i<NumOfImage;i++)
	{
		arr_Str1[i]=new char [1024];
		camfile[i].CamIndex=camfile[i].ImgIndex/(StripNum*ImageNumpStrip)+1;
		camfile[i].StripIndex=camfile[i].ImgIndex%(StripNum*ImageNumpStrip);
		camfile[i].PhotoIndex=camfile[i].StripIndex%ImageNumpStrip+1;
		camfile[i].StripIndex=camfile[i].StripIndex/ImageNumpStrip+1;
		sprintf(arr_Str1[i],"F:\\20151102\\Oblique_key\\T05003_Cam%d_%03d_TIFF100_001003%03d%03dcam%d_100.key",camfile[i].CamIndex,camfile[i].StripIndex,camfile[i].StripIndex,camfile[i].PhotoIndex,camfile[i].CamIndex);
	}
	FILE* fpCoor;
	CvPoint2D32f** Corr_Coors=new CvPoint2D32f* [NumOfImage];
	CvPoint2D32f corrtemp;
	int* Corres_ptsnumarr=new int [NumOfImage];
	int Sift_dim;
	for(int i=0;i<NumOfImage;i++)
	{
		fpCoor=fopen(arr_Str1[i],"r");
		fscanf(fpCoor,"%d",&Corres_ptsnum);
		fscanf(fpCoor,"%d",&Sift_dim);
		Corr_Coors[i]=new CvPoint2D32f [Corres_ptsnum];
		Corres_ptsnumarr[i]=Corres_ptsnum;
		for(int j=0;j<Corres_ptsnum;j++)
		{
			fscanf(fpCoor,"%f%f",&corrtemp.x,&corrtemp.y);
			Corr_Coors[i][j].x=corrtemp.x;
			Corr_Coors[i][j].y=corrtemp.y;
			fscanf(fpCoor,"%f%f",&corrtemp.x,&corrtemp.y);
			for(int k=0;k<Sift_dim;k++)
			{
				fscanf(fpCoor,"%d",&dhehe);
			}
		}
		fclose(fpCoor);
	}
#pragma omp parallel for
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			for(int k=0;k<MatchNum[i*NumOfImage+j];k++)
			{
				if(MatchIndex[i*NumOfImage+j][k].x<Corres_ptsnumarr[i]&&MatchIndex[i*NumOfImage+j][k].y<Corres_ptsnumarr[j])
				{
					CorresCoordinate[i*NumOfImage+j][k].x1=Corr_Coors[i][MatchIndex[i*NumOfImage+j][k].x].x;
					CorresCoordinate[i*NumOfImage+j][k].y1=Corr_Coors[i][MatchIndex[i*NumOfImage+j][k].x].y;
					CorresCoordinate[i*NumOfImage+j][k].x2=Corr_Coors[j][MatchIndex[i*NumOfImage+j][k].y].x;
					CorresCoordinate[i*NumOfImage+j][k].y2=Corr_Coors[j][MatchIndex[i*NumOfImage+j][k].y].y;
					CorresCoordinate[i*NumOfImage+j][k].index1=MatchIndex[i*NumOfImage+j][k].x;
					CorresCoordinate[i*NumOfImage+j][k].index2=MatchIndex[i*NumOfImage+j][k].y;
					CorresCoordinate[i*NumOfImage+j][k].value=-1;
					RealMatchNum[i*NumOfImage+j]++;
				}
				else
				{
					CorresCoordinate[i*NumOfImage+j][k].x1=-10000;
					CorresCoordinate[i*NumOfImage+j][k].y1=-10000;
					CorresCoordinate[i*NumOfImage+j][k].x2=-10000;
					CorresCoordinate[i*NumOfImage+j][k].y2=-10000;
					CorresCoordinate[i*NumOfImage+j][k].value=-1;
				}
			}
		}
	}
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			if(MatchIndex[i*NumOfImage+j])
				delete[] MatchIndex[i*NumOfImage+j];
		}
	}
	for(int i=0;i<NumOfImage;i++)
	{
		delete [] Corr_Coors[i];
	}
	CvFont hfont;
	cvInitFont(&hfont,CV_FONT_HERSHEY_SIMPLEX,1.0,1.0,0,3,8);
	char str_left1[1024];
	char str_right1[1024];
	char str_left2[1024];
	char str_right2[1024];
	char id1[1024];
	char id2[1024];
	int i=0;int j=12;
	if(MatchNum[i*NumOfImage+j]>0)
	{
	sprintf(str_left1,"F:\\20151102\\visualize\\%08d.jpg",i);
	sprintf(str_right1,"F:\\20151102\\visualize\\%08d.jpg",j);
	IplImage* img2=cvLoadImage(str_left1,3);
	IplImage* img3=cvLoadImage(str_right1,3);
	double x1,x2,y1,y2;
	for(int k=0;k<MatchNum[i*NumOfImage+j];k++)
	{
	if(CorresCoordinate[i*NumOfImage+j][k].x1!=-10000)
	{
	x1=CorresCoordinate[i*NumOfImage+j][k].x1;
	y1=CorresCoordinate[i*NumOfImage+j][k].y1;
	x2=CorresCoordinate[i*NumOfImage+j][k].x2;
	y2=CorresCoordinate[i*NumOfImage+j][k].y2;
	cvLine(img2,cvPoint(cvRound(y1)-10,cvRound(x1)),cvPoint(cvRound(y1)+10,cvRound(x1)),CV_RGB(255,0,0),2);
	cvLine(img2,cvPoint(cvRound(y1),cvRound(x1)-10),cvPoint(cvRound(y1),cvRound(x1)+10),CV_RGB(255,0,0),2);
	cvLine(img3,cvPoint(cvRound(y2)-10,cvRound(x2)),cvPoint(cvRound(y2)+10,cvRound(x2)),CV_RGB(255,0,0),2);
	cvLine(img3,cvPoint(cvRound(y2),cvRound(x2)-10),cvPoint(cvRound(y2),cvRound(x2)+10),CV_RGB(255,0,0),2);
	sprintf(id1,"%d",CorresCoordinate[i*NumOfImage+j][k].index1);
	sprintf(id2,"%d",CorresCoordinate[i*NumOfImage+j][k].index2);
	cvPutText(img2,id1,cvPoint(cvRound(y1)-30,cvRound(x1)-30),&hfont,CV_RGB(0,0,0));
	cvPutText(img3,id2,cvPoint(cvRound(y2)-30,cvRound(x2)-30),&hfont,CV_RGB(0,0,0));
	}
	}
	sprintf(str_left2,"F:\\res2\\_%02d_%02d_left.jpg",i,j);
	sprintf(str_right2,"F:\\res2\\_%02d_%02d_right.jpg",i,j);
	cvSaveImage(str_left2,img2);
	cvSaveImage(str_right2,img3);
	cvReleaseImage(&img2);
	cvReleaseImage(&img3);
	}
	///////////////////////////////////////////////////////////////////////////////
	Interior_Orientation( camfile, CorresCoordinate, MatchNum, NumOfCam,NumOfImage,cams,arr_Str1);
	double* arr_Xs=new double [NumOfImage];
	double* arr_Ys=new double [NumOfImage];
	double* arr_Zs=new double [NumOfImage];
	double* arr_fai=new double [NumOfImage];
	double* arr_omiga=new double [NumOfImage];
	double* arr_kappa=new double [NumOfImage];
	double* arr_fh=new double [NumOfImage];
	int count=0;
	FILE* fpInitial;
	fpInitial=fopen("F:\\killkillkill3720\\Generated_Exterior_Elements.txt","r");
	while(!feof(fpInitial))
	{
		fscanf(fpInitial,"%lf%lf%lf%lf%lf%lf%lf",&arr_Xs[count],&arr_Ys[count],&arr_Zs[count],&arr_fai[count],&arr_omiga[count],&arr_kappa[count],&arr_fh[count]);
		count++;
	}
	//先看一下连通图
	Purify10000(CorresCoordinate,MatchNum,RealMatchNum,NumOfImage);
	int value=0;
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			for(int k=0;k<RealMatchNum[i*NumOfImage+j];k++)
			{
				if(CorresCoordinate[i*NumOfImage+j][k].value==-1)
				{
					ObjectSpacePoint(i,j,k,value,NumOfImage,CorresCoordinate,RealMatchNum);
					value++;
				}
			}
		}
	}
	FILE*  fpOneNum;
	fpOneNum=fopen("F:\\OneNum.txt","w");
	fprintf(fpOneNum,"%d\n",value);
	fclose(fpOneNum);
	CvMat* msB=cvCreateMat(5,5,CV_32FC1);
	CvMat* msL=cvCreateMat(5,1,CV_32FC1);
	CvMat* mR1=cvCreateMat(3,3,CV_32FC1);
	CvMat* mR2=cvCreateMat(3,3,CV_32FC1);
	CvMat* msX=cvCreateMat(5,1,CV_32FC1);
	CvMat* mF_fai2=cvCreateMat(3,3,CV_32FC1);
	CvMat* mF_omiga2=cvCreateMat(3,3,CV_32FC1);
	CvMat* mF_kappa2=cvCreateMat(3,3,CV_32FC1);
	CvMat* mF0=cvCreateMat(3,3,CV_32FC1);
	CvMat* mB;
	CvMat* mL;
    CvMat* mV;
	int Diedaicishu=200;
	vector<int>* AllInliers=new vector<int>[Diedaicishu];
	int* Inlier_num=new int [Diedaicishu];
	vector<int> Inliers_Chosen;
	int Ransac_interator=0;
	int RSCheck_interator=0;
	double Xs1,Ys1,Zs1,Xs2,Ys2,Zs2;
	double fai1,omiga1,kappa1,fai2,omiga2,kappa2;
	double x1,y1,x2,y2,f1,f2;
	double F_Ys2,F_Zs2,F_fai2,F_omiga2,F_kappa2,F0;
	double BLength;
	double X1,Y1,Z1,X2,Y2,Z2;
	int CMaxChoice,IMaxChoice;
	double Ave_L,Max_L,Ele_L;
	double dYs,dZs,dfai,domiga,dkappa;
	FILE* fpPured;
	fpPured=fopen("F:\\killkillkill3720\\SelectedCoordinates_New2.txt","w");
	FILE* fpdPured;
	fpdPured=fopen("F:\\killkillkill3720\\SelectedCoordinates_New2d.txt","w");
	//////////////////////////////////////////////////////////////
	//把原始数据输出
	FILE* fpunPured;
	fpunPured=fopen("F:\\killkillkill3720\\SelectedCoordinates_1104.txt","w");
	for(int i=0;i<NumOfImage;i++)
	{
	for(int j=0;j<NumOfImage;j++)
	{
	fprintf(fpunPured,"%d\t%d\t%d\t",i,j,RealMatchNum[i*NumOfImage+j]);
	for(int k=0;k<RealMatchNum[i*NumOfImage+j];k++)
	{
	fprintf(fpunPured,"%lf\t",CorresCoordinate[i*NumOfImage+j][k].x1);
	}
	for(int k=0;k<RealMatchNum[i*NumOfImage+j];k++)
	{
	fprintf(fpunPured,"%lf\t",CorresCoordinate[i*NumOfImage+j][k].y1);
	}
	for(int k=0;k<RealMatchNum[i*NumOfImage+j];k++)
	{
	fprintf(fpunPured,"%lf\t",CorresCoordinate[i*NumOfImage+j][k].x2);
	}
	for(int k=0;k<RealMatchNum[i*NumOfImage+j];k++)
	{
	fprintf(fpunPured,"%lf\t",CorresCoordinate[i*NumOfImage+j][k].y2);
	}
	fprintf(fpunPured,"\n");
	}
	}
	fclose(fpunPured);
	//////////////////////////////////////////////////////////////
	int* coGraph=new int [NumOfImage*NumOfImage];
	int* coDistance=new int [NumOfImage*NumOfImage];
	CorresPoint** puredPoints=new CorresPoint* [NumOfImage*NumOfImage]; 
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			if(i==j)
			{
				coGraph[i*NumOfImage+j]=0;
			    coDistance[i*NumOfImage+j]=0;
			}
			else
			{
			    coGraph[i*NumOfImage+j]=0;
			    coDistance[i*NumOfImage+j]=MAXVALUE;
			}
		}
	}
	FILE* fpCheck;
	fpCheck=fopen("F:\\killkillkill3720\\CheckRobust.txt","w");
	FILE* fpValue;
	fpValue=fopen("F:\\killkillkill3720\\Value.txt","w");
	for(int No_left=0;No_left<NumOfImage;No_left++)
	{
		bool stop;
		printf("%d\n",No_left);
		for(int No_right=0;No_right<NumOfImage;No_right++)
		{
			if(RealMatchNum[No_left*NumOfImage+No_right]<=5)
			{
				fprintf(fpPured,"%d\t%d\t%d\t\n",No_left,No_right,0);
				fprintf(fpValue,"%d\t%d\t%d\t\n",No_left,No_right,0);
				fprintf(fpCheck,"%6d%6d%8d\n",No_left,No_right,0);	
				continue;
			}
			
			vector <int> Shulie_ix;
			for(int i=0;i<RealMatchNum[No_left*NumOfImage+No_right];i++)
			{
				Shulie_ix.push_back(i);
			}
			if(fabs(arr_fai[No_left]-arr_fai[No_right])<0.2&&fabs(arr_omiga[No_left]-arr_omiga[No_right])<0.2&&fabs(arr_kappa[No_left]-arr_kappa[No_right])<0.2)
			{
				ransac_threshold=0.0025;
			}
			else
			{
				ransac_threshold=0.0025;
			}
			for(int i=0;i<Diedaicishu;i++)
			{
				random_shuffle(Shulie_ix.begin(),Shulie_ix.end());
				//Shulie_ix[0]=10;
				//Shulie_ix[1]=20;
				//Shulie_ix[2]=30;
				//Shulie_ix[3]=40;
				//Shulie_ix[4]=50;
				Ransac_interator=0;
				Xs1=arr_Xs[No_left];Ys1=arr_Ys[No_left];Zs1=arr_Zs[No_left];
				Xs2=arr_Xs[No_right];Ys2=arr_Ys[No_right];Zs2=arr_Zs[No_right];
				fai1=arr_fai[No_left];omiga1=arr_omiga[No_left];kappa1=arr_kappa[No_left];
				fai2=arr_fai[No_right];omiga2=arr_omiga[No_right];kappa2=arr_kappa[No_right];
				f1=cams[camfile[No_left].CamIndex-1].f;
				f2=cams[camfile[No_right].CamIndex-1].f;
				stop=false;
				while(Ransac_interator<10)
				{
					Ransac_interator+=1;
					Calculate_Matrix_R(mR1,fai1,omiga1,kappa1);
					Calculate_Matrix_R(mR2,fai2,omiga2,kappa2);
					BLength=sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2));
					for(int k=0;k<5;k++)
					{

						x1=CorresCoordinate[No_left*NumOfImage+No_right][Shulie_ix[k]].x1;
						y1=CorresCoordinate[No_left*NumOfImage+No_right][Shulie_ix[k]].y1;
						x2=CorresCoordinate[No_left*NumOfImage+No_right][Shulie_ix[k]].x2;
						y2=CorresCoordinate[No_left*NumOfImage+No_right][Shulie_ix[k]].y2;
						xyz2XYZ(mR1,x1,y1,-f1,&X1,&Y1,&Z1);
						xyz2XYZ(mR2,x2,y2,-f2,&X2,&Y2,&Z2);
						//计算F0
						cvSetReal2D(mF0,0,0,Xs2-Xs1);
						cvSetReal2D(mF0,0,1,Ys2-Ys1);
						cvSetReal2D(mF0,0,2,Zs2-Zs1);
						cvSetReal2D(mF0,1,0,X1);
						cvSetReal2D(mF0,1,1,Y1);
						cvSetReal2D(mF0,1,2,Z1);
						cvSetReal2D(mF0,2,0,X2);
						cvSetReal2D(mF0,2,1,Y2);
						cvSetReal2D(mF0,2,2,Z2);
						F0=cvDet(mF0)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)));
						//计算F_Ys2,F_Zs2
						F_Ys2=1/sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2))+(cvDet(mF0)*(Ys2-Ys1))/((X1*Z2-X2*Z1)*pow(BLength,3));
						F_Zs2=-(X1*Y2-X2*Y1)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)))+(cvDet(mF0)*(Zs2-Zs1))/((X1*Z2-X2*Z1)*pow(BLength,3));
						//计算对fai2的偏导
						cvSetReal2D(mF_fai2,0,0,Xs2-Xs1);
						cvSetReal2D(mF_fai2,0,1,Ys2-Ys1);
						cvSetReal2D(mF_fai2,0,2,Zs2-Zs1);
						cvSetReal2D(mF_fai2,1,0,X1);
						cvSetReal2D(mF_fai2,1,1,Y1);
						cvSetReal2D(mF_fai2,1,2,Z1);
						cvSetReal2D(mF_fai2,2,0,-Z2);
						cvSetReal2D(mF_fai2,2,1,0);
						cvSetReal2D(mF_fai2,2,2,X2);
						F_fai2=-cvDet(mF_fai2)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)))+(cvDet(mF0)*(X1*X2+Z1*Z2))/(BLength*(X1*Z2-X2*Z1)*(X1*Z2-X2*Z1));
						//计算对omiga2的偏导
						cvSetReal2D(mF_omiga2,0,0,Xs2-Xs1);
						cvSetReal2D(mF_omiga2,0,1,Ys2-Ys1);
						cvSetReal2D(mF_omiga2,0,2,Zs2-Zs1);
						cvSetReal2D(mF_omiga2,1,0,X1);
						cvSetReal2D(mF_omiga2,1,1,Y1);
						cvSetReal2D(mF_omiga2,1,2,Z1);
						cvSetReal2D(mF_omiga2,2,0,-Y2*sin(fai2));
						cvSetReal2D(mF_omiga2,2,1,X2*sin(fai2)-Z2*cos(fai2));
						cvSetReal2D(mF_omiga2,2,2,Y2*cos(fai2));
						F_omiga2=-cvDet(mF_omiga2)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)))+(cvDet(mF0)*(X1*Y2*cos(fai2)+Z1*Y2*sin(fai2)))/(BLength*(X1*Z2-X2*Z1)*(X1*Z2-X2*Z1));
						//计算对kappa2的偏导
						cvSetReal2D(mF_kappa2,0,0,Xs2-Xs1);
						cvSetReal2D(mF_kappa2,0,1,Ys2-Ys1);
						cvSetReal2D(mF_kappa2,0,2,Zs2-Zs1);
						cvSetReal2D(mF_kappa2,1,0,X1);
						cvSetReal2D(mF_kappa2,1,1,Y1);
						cvSetReal2D(mF_kappa2,1,2,Z1);
						cvSetReal2D(mF_kappa2,2,0,-Y2*cos(fai2)*cos(omiga2)-Z2*sin(omiga2));
						cvSetReal2D(mF_kappa2,2,1,X2*cos(fai2)*cos(omiga2)+Z2*sin(fai2)*cos(omiga2));
						cvSetReal2D(mF_kappa2,2,2,X2*sin(omiga2)-Y2*sin(fai2)*cos(omiga2));
						F_kappa2=-cvDet(mF_kappa2)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)))+(cvDet(mF0)*(X1*X2*sin(omiga2)-X1*Y2*sin(fai2)*cos(omiga2)+Z1*Y2*cos(fai2)*cos(omiga2)+Z1*Z2*sin(omiga2)))/(BLength*(X1*Z2-X2*Z1)*(X1*Z2-X2*Z1));

						cvSetReal2D(msB,k,0,F_Ys2);
						cvSetReal2D(msB,k,1,F_Zs2);
						cvSetReal2D(msB,k,2,F_fai2);
						cvSetReal2D(msB,k,3,F_omiga2);
						cvSetReal2D(msB,k,4,F_kappa2);
						cvSetReal2D(msL,k,0,F0);
					}
					cvSolve(msB,msL,msX);
					Ys2+=cvGetReal2D(msX,0,0);
					Zs2+=cvGetReal2D(msX,1,0);
					fai2+=cvGetReal2D(msX,2,0);
					omiga2+=cvGetReal2D(msX,3,0);
					kappa2+=cvGetReal2D(msX,4,0);
					/*if(fabs(cvGetReal2D(msX,2,0))<0.00003&&fabs(cvGetReal2D(msX,3,0))<0.00003&&fabs(cvGetReal2D(msX,4,0))<0.00003)
					{
						stop=true;
					}*/
				}
				Calculate_Matrix_R(mR1,fai1,omiga1,kappa1);
				Calculate_Matrix_R(mR2,fai2,omiga2,kappa2);
				BLength=sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2));
				vector<int> Inliers;
				for(int j=0;j<RealMatchNum[No_left*NumOfImage+No_right];j++)
				{
					x1=CorresCoordinate[No_left*NumOfImage+No_right][j].x1;
					y1=CorresCoordinate[No_left*NumOfImage+No_right][j].y1;
					x2=CorresCoordinate[No_left*NumOfImage+No_right][j].x2;
					y2=CorresCoordinate[No_left*NumOfImage+No_right][j].y2;
					xyz2XYZ(mR1,x1,y1,-f1,&X1,&Y1,&Z1);
					xyz2XYZ(mR2,x2,y2,-f2,&X2,&Y2,&Z2);
					cvSetReal2D(mF0,0,0,Xs2-Xs1);
					cvSetReal2D(mF0,0,1,Ys2-Ys1);
					cvSetReal2D(mF0,0,2,Zs2-Zs1);
					cvSetReal2D(mF0,1,0,X1);
					cvSetReal2D(mF0,1,1,Y1);
					cvSetReal2D(mF0,1,2,Z1);
					cvSetReal2D(mF0,2,0,X2);
					cvSetReal2D(mF0,2,1,Y2);
					cvSetReal2D(mF0,2,2,Z2);
					F0=cvDet(mF0)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)));
					if(fabs(F0)<ransac_threshold)
					{
						Inliers.push_back(j);
					}
				}
				AllInliers[i]=Inliers;
				Inlier_num[i]=Inliers.size();
				Inliers.clear();
				dYs=fabs(cvGetReal2D(msX,0,0));
				dZs=fabs(cvGetReal2D(msX,1,0));
				dfai=fabs(cvGetReal2D(msX,2,0));
				domiga=fabs(cvGetReal2D(msX,3,0));
				dkappa=fabs(cvGetReal2D(msX,4,0));
				if(dYs>0.01||dZs>0.01||dfai>0.001||domiga>0.001||dkappa>0.001)
				{
				    AllInliers[i]=Inliers;
				    Inlier_num[i]=Inliers.size();
				}
			}
			Shulie_ix.clear();
			CMaxChoice=MINVALUE;
			for(int i=0;i<Diedaicishu;i++)
			{
				if(Inlier_num[i]>CMaxChoice)
				{
					CMaxChoice=Inlier_num[i];
					IMaxChoice=i;
				}
			}
			if(CMaxChoice>20)
			{
				coGraph[No_left*NumOfImage+No_right]=1;
				coGraph[No_right*NumOfImage+No_left]=1;
			}
			fprintf(fpPured,"%d\t%d\t",No_left,No_right);
			fprintf(fpValue,"%d\t%d\t",No_left,No_right);
			fprintf(fpdPured,"%d\t%d\t",No_left,No_right);
			fprintf(fpCheck,"%6d%6d%8d",No_left,No_right,CMaxChoice);
			if(CMaxChoice<20)
			{
				fprintf(fpCheck,"\n");
				fprintf(fpPured,"%d\n",0);
				fprintf(fpValue,"%d\n",0);
				fprintf(fpdPured,"%d\n",0);
				puredPoints[No_left*NumOfImage+No_right]=NULL;
				PureMatchNum[No_left*NumOfImage+No_right]=0;
				continue;
			}
			RSCheck_interator=0;
			Inliers_Chosen=AllInliers[IMaxChoice];
			mB=cvCreateMat(CMaxChoice,5,CV_32FC1);
			mL=cvCreateMat(CMaxChoice,1,CV_32FC1);
			mV=cvCreateMat(CMaxChoice,1,CV_32FC1);
			Xs1=arr_Xs[No_left];Ys1=arr_Ys[No_left];Zs1=arr_Zs[No_left];
			Xs2=arr_Xs[No_right];Ys2=arr_Ys[No_right];Zs2=arr_Zs[No_right];
			fai1=arr_fai[No_left];omiga1=arr_omiga[No_left];kappa1=arr_kappa[No_left];
			fai2=arr_fai[No_right];omiga2=arr_omiga[No_right];kappa2=arr_kappa[No_right];
			stop=false;
			while(RSCheck_interator<10)
			{
				RSCheck_interator++;
				Calculate_Matrix_R(mR1,fai1,omiga1,kappa1);
				Calculate_Matrix_R(mR2,fai2,omiga2,kappa2);
				BLength=sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2));
				for(int k=0;k<CMaxChoice;k++)
				{
					x1=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[k]].x1;
					y1=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[k]].y1;
					x2=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[k]].x2;
					y2=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[k]].y2;
					f1=cams[camfile[No_left].CamIndex-1].f;
					f2=cams[camfile[No_right].CamIndex-1].f;
					xyz2XYZ(mR1,x1,y1,-f1,&X1,&Y1,&Z1);
					xyz2XYZ(mR2,x2,y2,-f2,&X2,&Y2,&Z2);
					cvSetReal2D(mF0,0,0,Xs2-Xs1);
					cvSetReal2D(mF0,0,1,Ys2-Ys1);
					cvSetReal2D(mF0,0,2,Zs2-Zs1);
					cvSetReal2D(mF0,1,0,X1);
					cvSetReal2D(mF0,1,1,Y1);
					cvSetReal2D(mF0,1,2,Z1);
					cvSetReal2D(mF0,2,0,X2);
					cvSetReal2D(mF0,2,1,Y2);
					cvSetReal2D(mF0,2,2,Z2);
					F0=cvDet(mF0)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)));
					//计算F_Ys2,F_Zs2
					F_Ys2=1/sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2))+(cvDet(mF0)*(Ys2-Ys1))/((X1*Z2-X2*Z1)*pow(BLength,3));
					F_Zs2=-(X1*Y2-X2*Y1)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)))+(cvDet(mF0)*(Zs2-Zs1))/((X1*Z2-X2*Z1)*pow(BLength,3));
					//计算对fai2的偏导
					cvSetReal2D(mF_fai2,0,0,Xs2-Xs1);
					cvSetReal2D(mF_fai2,0,1,Ys2-Ys1);
					cvSetReal2D(mF_fai2,0,2,Zs2-Zs1);
					cvSetReal2D(mF_fai2,1,0,X1);
					cvSetReal2D(mF_fai2,1,1,Y1);
					cvSetReal2D(mF_fai2,1,2,Z1);
					cvSetReal2D(mF_fai2,2,0,-Z2);
					cvSetReal2D(mF_fai2,2,1,0);
					cvSetReal2D(mF_fai2,2,2,X2);
					F_fai2=-cvDet(mF_fai2)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)))+(cvDet(mF0)*(X1*X2+Z1*Z2))/(BLength*(X1*Z2-X2*Z1)*(X1*Z2-X2*Z1));
					//计算对omiga2的偏导
					cvSetReal2D(mF_omiga2,0,0,Xs2-Xs1);
					cvSetReal2D(mF_omiga2,0,1,Ys2-Ys1);
					cvSetReal2D(mF_omiga2,0,2,Zs2-Zs1);
					cvSetReal2D(mF_omiga2,1,0,X1);
					cvSetReal2D(mF_omiga2,1,1,Y1);
					cvSetReal2D(mF_omiga2,1,2,Z1);
					cvSetReal2D(mF_omiga2,2,0,-Y2*sin(fai2));
					cvSetReal2D(mF_omiga2,2,1,X2*sin(fai2)-Z2*cos(fai2));
					cvSetReal2D(mF_omiga2,2,2,Y2*cos(fai2));
					F_omiga2=-cvDet(mF_omiga2)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)))+(cvDet(mF0)*(X1*Y2*cos(fai2)+Z1*Y2*sin(fai2)))/(BLength*(X1*Z2-X2*Z1)*(X1*Z2-X2*Z1));
					//计算对kappa2的偏导
					cvSetReal2D(mF_kappa2,0,0,Xs2-Xs1);
					cvSetReal2D(mF_kappa2,0,1,Ys2-Ys1);
					cvSetReal2D(mF_kappa2,0,2,Zs2-Zs1);
					cvSetReal2D(mF_kappa2,1,0,X1);
					cvSetReal2D(mF_kappa2,1,1,Y1);
					cvSetReal2D(mF_kappa2,1,2,Z1);
					cvSetReal2D(mF_kappa2,2,0,-Y2*cos(fai2)*cos(omiga2)-Z2*sin(omiga2));
					cvSetReal2D(mF_kappa2,2,1,X2*cos(fai2)*cos(omiga2)+Z2*sin(fai2)*cos(omiga2));
					cvSetReal2D(mF_kappa2,2,2,X2*sin(omiga2)-Y2*sin(fai2)*cos(omiga2));
					F_kappa2=-cvDet(mF_kappa2)/((X1*Z2-X2*Z1)*sqrt(pow(Xs2-Xs1,2)+pow(Ys2-Ys1,2)+pow(Zs2-Zs1,2)))+(cvDet(mF0)*(X1*X2*sin(omiga2)-X1*Y2*sin(fai2)*cos(omiga2)+Z1*Y2*cos(fai2)*cos(omiga2)+Z1*Z2*sin(omiga2)))/(BLength*(X1*Z2-X2*Z1)*(X1*Z2-X2*Z1));
				    
					cvSetReal2D(mB,k,0,F_Ys2);
					cvSetReal2D(mB,k,1,F_Zs2);
					cvSetReal2D(mB,k,2,F_fai2);
					cvSetReal2D(mB,k,3,F_omiga2);
					cvSetReal2D(mB,k,4,F_kappa2);
					cvSetReal2D(mL,k,0,F0);
				}
				cvSolve(mB,mL,msX);
				Ys2+=cvGetReal2D(msX,0,0);
				Zs2+=cvGetReal2D(msX,1,0);
				fai2+=cvGetReal2D(msX,2,0);
				omiga2+=cvGetReal2D(msX,3,0);
				kappa2+=cvGetReal2D(msX,4,0);
			/*	if(fabs(cvGetReal2D(msX,2,0))<0.00003&&fabs(cvGetReal2D(msX,3,0))<0.00003&&fabs(cvGetReal2D(msX,4,0))<0.00003)
				{
					stop=true;
				}*/
			}
			Max_L=MINVALUE;
			Ave_L=0;
			for(int i=0;i<CMaxChoice;i++)
			{
				Ele_L=fabs(cvGetReal2D(mL,i,0));
				if(Ele_L>Max_L)Max_L=Ele_L;
				Ave_L+=Ele_L;
			}
			Ave_L=Ave_L/CMaxChoice;
			dYs=fabs(cvGetReal2D(msX,0,0));
			dZs=fabs(cvGetReal2D(msX,1,0));
			dfai=fabs(cvGetReal2D(msX,2,0));
			domiga=fabs(cvGetReal2D(msX,3,0));
			dkappa=fabs(cvGetReal2D(msX,4,0));
			if(dYs>0.01||dZs>0.01||dfai>0.001||domiga>0.001||dkappa>0.001)
			{
				//Do nothing.
				coGraph[No_left*NumOfImage+No_right]=0;
				coGraph[No_right*NumOfImage+No_left]=0;
				fprintf(fpPured,"%d\n",0);
				fprintf(fpValue,"%d\n",0);
				fprintf(fpdPured,"%d\n",0);
				fprintf(fpCheck,"\n");
				puredPoints[No_left*NumOfImage+No_right]=NULL;
				PureMatchNum[No_left*NumOfImage+No_right]=0;
			}
			else
			{
			    fprintf(fpCheck,"%10.6lf%10.6lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",Max_L,Ave_L,arr_Xs[No_left],arr_Ys[No_left],arr_Zs[No_left],arr_fai[No_left],arr_omiga[No_left],arr_kappa[No_left],arr_Xs[No_right],Ys2,Zs2,fai2,omiga2,kappa2);
				fprintf(fpPured,"%d\t",CMaxChoice);
				fprintf(fpValue,"%d\t",CMaxChoice);
				fprintf(fpdPured,"%d\t",CMaxChoice);
				for(int i=0;i<CMaxChoice;i++)
				{
					fprintf(fpPured,"%lf\t",CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].x1);
					fprintf(fpdPured,"%d\t",CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].row1);
					fprintf(fpValue,"%d\t",CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].value);
				}
				for(int i=0;i<CMaxChoice;i++)
				{
					fprintf(fpPured,"%lf\t",CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].y1);
					fprintf(fpdPured,"%d\t",CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].col1);
				}
				for(int i=0;i<CMaxChoice;i++)
				{
					fprintf(fpPured,"%lf\t",CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].x2);
					fprintf(fpdPured,"%d\t",CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].row2);
				}
				for(int i=0;i<CMaxChoice;i++)
				{
					fprintf(fpPured,"%lf\t",CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].y2);
					fprintf(fpdPured,"%d\t",CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].col2);
				}
				fprintf(fpValue,"\n");
				fprintf(fpPured,"\n");
				fprintf(fpdPured,"\n");
				puredPoints[No_left*NumOfImage+No_right]=new CorresPoint [CMaxChoice];
				PureMatchNum[No_left*NumOfImage+No_right]=CMaxChoice;
				for(int i=0;i<CMaxChoice;i++)
				{
					puredPoints[No_left*NumOfImage+No_right][i].x1=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].x1;
					puredPoints[No_left*NumOfImage+No_right][i].y1=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].y1;
					puredPoints[No_left*NumOfImage+No_right][i].x2=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].x2;
					puredPoints[No_left*NumOfImage+No_right][i].y2=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].y2;
					puredPoints[No_left*NumOfImage+No_right][i].value=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].value;
					puredPoints[No_left*NumOfImage+No_right][i].index1=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].index1;
					puredPoints[No_left*NumOfImage+No_right][i].index2=CorresCoordinate[No_left*NumOfImage+No_right][Inliers_Chosen[i]].index2;
				}
			}
			cvGEMM(mB,msX,1,mL,-1,mV);
			cvReleaseMat(&mB);
			cvReleaseMat(&mL);
			cvReleaseMat(&mV);
		}
	}
	fclose(fpPured);
	fclose(fpValue);
	fclose(fpCheck);
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			if(CorresCoordinate[i*NumOfImage+j])
				delete[] CorresCoordinate[i*NumOfImage+j];
		}
	}
	vector<IpsOfOp>* arr_IpsOfOp=new vector<IpsOfOp> [value];
    IpsOfOp ele_IpsOfOp;
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			for(int k=0;k<PureMatchNum[i*NumOfImage+j];k++)
			{
				if(puredPoints[i*NumOfImage+j][k].value!=-1)
				{
					ele_IpsOfOp.i=i;
					ele_IpsOfOp.j=j;
					ele_IpsOfOp.k=k;
					arr_IpsOfOp[puredPoints[i*NumOfImage+j][k].value].push_back(ele_IpsOfOp);
				}
			}
		}
	}
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			for(int k=0;k<PureMatchNum[i*NumOfImage+j];k++)
			{
				if(puredPoints[i*NumOfImage+j][k].value==-1)
					puredPoints[i*NumOfImage+j][k].overlap=2;
				else
					puredPoints[i*NumOfImage+j][k].overlap=arr_IpsOfOp[puredPoints[i*NumOfImage+j][k].value].size();
			}
		}
	}
	int *Pure3MatchNum=new int [NumOfImage*NumOfImage];
	int count3pts;
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			if(PureMatchNum[i*NumOfImage+j]==0)
			{
				Pure3MatchNum[i*NumOfImage+j]=0;
				continue;
			}
			else
			{
				count3pts=0;
				for(int k=0;k<PureMatchNum[i*NumOfImage+j];k++)
				{
					if(puredPoints[i*NumOfImage+j][k].overlap>2)
						count3pts++;
				}
				Pure3MatchNum[i*NumOfImage+j]=count3pts;
			}
		}
	}
	FILE* fpPured3;
	fpPured3=fopen("F:\\killkillkill3720\\SelectedCoordinates_New3.txt","w");
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			fprintf(fpPured3,"%d\t%d\t",i,j);
			if(Pure3MatchNum[i*NumOfImage+j]==0)
			{
				fprintf(fpPured3,"0\n");
				continue;
			}
			fprintf(fpPured3,"%d\t",Pure3MatchNum[i*NumOfImage+j]);
			for(int k=0;k<PureMatchNum[i*NumOfImage+j];k++)
			{
				if(puredPoints[i*NumOfImage+j][k].overlap>2)
				{
					fprintf(fpPured3,"%lf\t",puredPoints[i*NumOfImage+j][k].x1);
				}
			}
			for(int k=0;k<PureMatchNum[i*NumOfImage+j];k++)
			{
				if(puredPoints[i*NumOfImage+j][k].overlap>2)
				{
					fprintf(fpPured3,"%lf\t",puredPoints[i*NumOfImage+j][k].y1);
				}
			}
			for(int k=0;k<PureMatchNum[i*NumOfImage+j];k++)
			{
				if(puredPoints[i*NumOfImage+j][k].overlap>2)
				{
					fprintf(fpPured3,"%lf\t",puredPoints[i*NumOfImage+j][k].x2);
				}
			}
			for(int k=0;k<PureMatchNum[i*NumOfImage+j];k++)
			{
				if(puredPoints[i*NumOfImage+j][k].overlap>2)
				{
					fprintf(fpPured3,"%lf\t",puredPoints[i*NumOfImage+j][k].y2);
				}
			}
			fprintf(fpPured3,"\n");
		}
	}
	fclose(fpPured3);
	FILE* fpCheck3;
	fpCheck3=fopen("F:\\killkillkill3720\\Overlap3Check.txt","w");
	for(int i=0;i<value;i++)
	{
		fprintf(fpCheck3,"%d\n",i);
		for(int j=0;j<arr_IpsOfOp[i].size();j++)
		{
			fprintf(fpCheck3,"%d\t%d\t%d\t%d\n",arr_IpsOfOp[i][j].i,puredPoints[arr_IpsOfOp[i][j].i*NumOfImage+arr_IpsOfOp[i][j].j][arr_IpsOfOp[i][j].k].index1,arr_IpsOfOp[i][j].j,puredPoints[arr_IpsOfOp[i][j].i*NumOfImage+arr_IpsOfOp[i][j].j][arr_IpsOfOp[i][j].k].index2);
		}
	}
	fclose(fpCheck3);
/*	int* coGraph=new int [NumOfImage*NumOfImage];
	int* coDistance=new int [NumOfImage*NumOfImage];
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			coGraph[i*NumOfImage+j]=0;
			coDistance[i*NumOfImage+j]=MAXVALUE;
		}
	}
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			if(MatchNum[i*NumOfImage+j]>0)
			{
				coGraph[i*NumOfImage+j]=1;
				coGraph[j*NumOfImage+i]=1;
			}
		}
	}
	Floyed(coGraph,coDistance,NumOfImage);
	int* Islandnote=new int [NumOfImage];
	int IslandNum;
	FindIsland(coGraph,coDistance,NumOfImage,Islandnote,&IslandNum);*/
	Floyed(coGraph,coDistance,NumOfImage);
	int* Islandnote=new int [NumOfImage];
	int IslandNum;
	FindIsland(coGraph,coDistance,NumOfImage,Islandnote,&IslandNum);
	cvWaitKey(0);
}
vector<int> Generate_and_Sort(double* arr_f,double xStep,double yStep,int whichFirst)
{
	int StripNum=24;
	int ImageNumpStrip=31;
	int dhehe;
	double fhehe;
	int nTotalPhotos=3719;
	FILE* fpEx;
	fpEx=fopen("F:\\20151102\\pos.txt","r");
	fscanf(fpEx,"%d",&dhehe);
	char sPhotoName[1024];
	Ex_Elements* ex_Elements=new Ex_Elements [nTotalPhotos];
	double fai,omiga,kappa,Xs,Ys,Zs;
	double X1,Y1,Z1;
	double N;
	double X,Y,Z;
	CvMat* R=cvCreateMat(3,3,CV_32FC1);
	//设置ROI区域
//	double yLr=3.996*pow(10,6);
//	double yUr=3.998*pow(10,6);
//	double xLr=2.58*pow(10,5);
//	double xUr=2.61*pow(10,5);
	//整个区域
	double yLr=3.9952*pow(10,6);
	double yUr=4.0032*pow(10,6);
	double xLr=2.574*pow(10,5);
	double xUr=2.64*pow(10,5);

//	double yLr=3.996*pow(10,6);
//	double yUr=3.997*pow(10,6);
//	double xLr=2.58*pow(10,5);
//	double xUr=2.59*pow(10,5);
	int xBlocks=floor((xUr-xLr)/xStep)+1;
	int yBlocks=floor((yUr-yLr)/yStep)+1;
	int xb,yb;
	int CamIndex,PhotoIndex,StripIndex,ImgIndex;
	vector<int>* PtsBlock_ind=new vector<int> [xBlocks*yBlocks];//记录与匹配点序号对应的像片号
	vector<int>* PtsBlock_seq=new vector<int> [xBlocks*yBlocks];//记录与ex_Elements数组中对应的像片号
	vector<int> Pts_ind;//最后搞到一个数组里
	for(int count=0;count<nTotalPhotos;count++)
	{
		fscanf(fpEx,"%s",sPhotoName);
		sscanf(sPhotoName,"CAM%d\\001003%dcam%d_Pro.tif",&CamIndex,&PhotoIndex,&dhehe);
		StripIndex=PhotoIndex/1000;
		PhotoIndex=PhotoIndex%1000;
		ImgIndex=(CamIndex-1)*StripNum*ImageNumpStrip+(StripIndex-1)*ImageNumpStrip+PhotoIndex-1;
		fscanf(fpEx,"%d",&dhehe);
		fscanf(fpEx,"%lf%lf%lf%lf%lf%lf%lf",&ex_Elements[count].Xs,&ex_Elements[count].Ys,&ex_Elements[count].Zs,&ex_Elements[count].fai,&ex_Elements[count].omiga,&ex_Elements[count].kappa,&fhehe);
	    ex_Elements[count].f=arr_f[CamIndex-1];
		Xs=ex_Elements[count].Xs; Ys=ex_Elements[count].Ys; Zs=ex_Elements[count].Zs;
		fai=ex_Elements[count].fai; omiga=ex_Elements[count].omiga; kappa=ex_Elements[count].kappa;
		Calculate_Matrix_R(R,fai,omiga,kappa);
		xyz2XYZ(R,0,0,-1,&X1,&Y1,&Z1);
		N=(60-Zs)/Z1;
		X=Xs+N*X1;
		Y=Ys+N*Y1;
		//不是按顺序排的，仍需计算像片号
		if(X<xUr&&X>xLr&&Y<yUr&&Y>yLr)
		{
			xb=floor((X-xLr+1)/xStep);
			yb=floor((Y-yLr+1)/yStep);
			PtsBlock_ind[xb*yBlocks+yb].push_back(ImgIndex);
			PtsBlock_seq[xb*yBlocks+yb].push_back(count);
		}
	}
	FILE* fpWriteEx;
	fpWriteEx=fopen("F:\\killkillkill3720\\Generated_Exterior_Elements.txt","w");
	int Seq;
	if(whichFirst==X_FIRST)
	{
		for(int y=0;y<yBlocks;y++)
		{
			for(int x=0;x<xBlocks;x++)
			{
				for(int k=0;k<PtsBlock_ind[x*yBlocks+y].size();k++)
				{
					Pts_ind.push_back(PtsBlock_ind[x*yBlocks+y][k]);
					Seq=PtsBlock_seq[x*yBlocks+y][k];
					fprintf(fpWriteEx,"%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",ex_Elements[Seq].Xs,ex_Elements[Seq].Ys,ex_Elements[Seq].Zs,-ex_Elements[Seq].fai,ex_Elements[Seq].omiga,ex_Elements[Seq].kappa,ex_Elements[Seq].f);
				}
			}
		}
	}
	else if (whichFirst==Y_FIRST)
	{
		for(int x=0;x<xBlocks;x++)
		{
			for(int y=0;y<yBlocks;y++)
			{
				for(int k=0;k<PtsBlock_ind[x*yBlocks+y].size();k++)
				{
					Pts_ind.push_back(PtsBlock_ind[x*yBlocks+y][k]);
					Seq=PtsBlock_seq[x*yBlocks+y][k];
					fprintf(fpWriteEx,"%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",ex_Elements[Seq].Xs,ex_Elements[Seq].Ys,ex_Elements[Seq].Zs,-ex_Elements[Seq].fai,ex_Elements[Seq].omiga,ex_Elements[Seq].kappa,ex_Elements[Seq].f);
				}
			}
		}
	}
	fclose(fpWriteEx);
	return Pts_ind;
}
void Calculate_Matrix_R(CvMat* R,double fai,double omiga,double kappa)
{
	CvMat* R_fai=cvCreateMat(3,3,CV_32FC1);
	CvMat* R_omiga=cvCreateMat(3,3,CV_32FC1);
	CvMat* R_kappa=cvCreateMat(3,3,CV_32FC1);
	CvMat* R_fai_omiga=cvCreateMat(3,3,CV_32FC1);
	for(int i=0;i<3;i++)
	{
		for(int j=0;j<3;j++)
		{
			cvSetReal2D(R_fai,i,j,0);
			cvSetReal2D(R_omiga,i,j,0);
			cvSetReal2D(R_kappa,i,j,0);
		}
	}
	cvSetReal2D(R_fai,0,0,cos(fai));
	cvSetReal2D(R_fai,0,2,-sin(fai));
	cvSetReal2D(R_fai,1,1,1);
	cvSetReal2D(R_fai,2,0,sin(fai));
	cvSetReal2D(R_fai,2,2,cos(fai));
	cvSetReal2D(R_omiga,0,0,1);
	cvSetReal2D(R_omiga,1,1,cos(omiga));
	cvSetReal2D(R_omiga,1,2,-sin(omiga));
	cvSetReal2D(R_omiga,2,1,sin(omiga));
	cvSetReal2D(R_omiga,2,2,cos(omiga));
	cvSetReal2D(R_kappa,0,0,cos(kappa));
	cvSetReal2D(R_kappa,0,1,-sin(kappa));
	cvSetReal2D(R_kappa,1,0,sin(kappa));
	cvSetReal2D(R_kappa,1,1,cos(kappa));
	cvSetReal2D(R_kappa,2,2,1);
	cvGEMM(R_fai,R_omiga,1,NULL,0,R_fai_omiga,0);
	cvGEMM(R_fai_omiga,R_kappa,1,NULL,0,R,0);
	cvReleaseMat(&R_fai);
	cvReleaseMat(&R_omiga);
	cvReleaseMat(&R_kappa);
	cvReleaseMat(&R_fai_omiga);
}
void xyz2XYZ(CvMat* R,double x,double y,double z,double* pX,double* pY,double* pZ)
{
	CvMat *mSrc=cvCreateMat(3,1,CV_32FC1);
	CvMat *mDst=cvCreateMat(3,1,CV_32FC1);
	cvSetReal2D(mSrc,0,0,x);
	cvSetReal2D(mSrc,1,0,y);
	cvSetReal2D(mSrc,2,0,z);
	cvGEMM(R,mSrc,1,NULL,0,mDst);
	*pX=cvGetReal2D(mDst,0,0);
	*pY=cvGetReal2D(mDst,1,0);
	*pZ=cvGetReal2D(mDst,2,0);
	cvReleaseMat(&mSrc);
	cvReleaseMat(&mDst); 
}
void Floyed(int* coGraph,int* coDistance,int NumOfImage)
{
	for(int k=0;k<NumOfImage;k++)
	{
		for(int i=0;i<NumOfImage;i++)
		{
			for(int j=0;j<NumOfImage;j++)
			{
				if(k==0)
				{
					if(coGraph[i*NumOfImage+j]==1)coDistance[i*NumOfImage+j]=1;
				}
				else
				{
					coDistance[i*NumOfImage+j]=MIN(coDistance[i*NumOfImage+j],coDistance[i*NumOfImage+k]+coDistance[k*NumOfImage+j]);
				}
			}
		}
	}
}
bool FindIsland(int* coGraph,int* coDistance,int NumOfImage,int* Islandnote,int *pIslandNum)
{
	bool flag=true;
	FILE* fpGraph;
	FILE* fpDistance;
	*pIslandNum=0;
	fpGraph=fopen("F:\\killkillkill3720\\Graph.txt","w");
	fpDistance=fopen("F:\\killkillkill3720\\Distance.txt","w");
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			fprintf(fpGraph,"%6d",coGraph[i*NumOfImage+j]);
			fprintf(fpDistance,"%6d",coDistance[i*NumOfImage+j]);
		}
		fprintf(fpGraph,"\n");
		fprintf(fpDistance,"\n");
	}
	fclose(fpGraph);
	fclose(fpDistance);
	int sum;
	for(int i=0;i<NumOfImage;i++)
	{
		sum=0;
		for(int j=0;j<NumOfImage;j++)
		{
			sum+=coGraph[i*NumOfImage+j];
		}
		if(sum<2)
		{
			flag=false;
			Islandnote[*pIslandNum]=i;
			*pIslandNum=*pIslandNum+1;
		}
	}
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
		    if(coDistance[i*NumOfImage+j]==MAXVALUE)
		    {
			    flag=false;
			    Islandnote[*pIslandNum]=i;
			    *pIslandNum=*pIslandNum+1;
		    }
		}
	}
	return flag;
}
void Interior_Orientation(Camfiles* camfile,CorresPoint** CorresCoordinate,int* MatchNum,int NumOfCam,int NumOfImage,Camera* cams,char** arr_Str1)
{
	//相片大小
	int* Height=new int [NumOfImage];
	int* Width=new int [NumOfImage];
	for(int i=0;i<NumOfImage;i++)
	{
		if(camfile[i].CamIndex<5)
		{
			Height[i]=5474;
			Width[i]=7312;
		}
		else
		{
			Height[i]=6000;
			Width[i]=9334;
		}
	}
	//Height[0]=5474;Height[1]=5474;Height[2]=5474;Height[3]=5474;Height[4]=6000;
	//Width[0]=7312;Width[1]=7312;Width[2]=7312;Width[3]=7312;Width[4]=9334;
	//将像素坐标转化为像平面坐标系
	char Interior_elementspath[1024];
	FILE* fpInterior;
	int suiyi1,suiyi2;
	for(int i=0;i<NumOfCam;i++)
	{
		sprintf(Interior_elementspath,"F:\\Data\\oblique\\TopDC5相机参数\\TOPDC5Cam%d_7_24.cam",i+1);
		fpInterior=fopen(Interior_elementspath,"r");
		fscanf(fpInterior,"机身NO:%d\n",&suiyi1);
		fscanf(fpInterior,"镜头NO:%d\n",&suiyi2);
		fscanf(fpInterior,"cellsize(mm):%lf\n",&cams[i].cellsize);
		fscanf(fpInterior,"f(mm):%lf\n",&cams[i].f);
		fscanf(fpInterior,"像主点xp(mm):%lf\n",&cams[i].xp);
		fscanf(fpInterior,"像主点yp(mm):%lf\n",&cams[i].yp);
		fscanf(fpInterior,"像主点yp(mm):%lf\n",&cams[i].yp);
		fscanf(fpInterior,"K1:%lf\n",&cams[i].k1);
		fscanf(fpInterior,"K2:%lf\n",&cams[i].k2);
		fscanf(fpInterior,"K3:%lf\n",&cams[i].k3);
		fscanf(fpInterior,"P1:%lf\n",&cams[i].p1);
		fscanf(fpInterior,"P2:%lf\n",&cams[i].p2);
		fclose(fpInterior);
	}
	double swap;
	double r;
	double dx1,dy1,dx2,dy2;
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			for(int k=0;k<MatchNum[i*NumOfImage+j];k++)
			{
				if(CorresCoordinate[i*NumOfImage+j][k].x1!=-10000||CorresCoordinate[i*NumOfImage+j][k].y1!=-10000||CorresCoordinate[i*NumOfImage+j][k].x2!=-10000||CorresCoordinate[i*NumOfImage+j][k].y2!=-10000)
				{
					CorresCoordinate[i*NumOfImage+j][k].row1=CorresCoordinate[i*NumOfImage+j][k].x1;
					CorresCoordinate[i*NumOfImage+j][k].col1=CorresCoordinate[i*NumOfImage+j][k].y1;
					CorresCoordinate[i*NumOfImage+j][k].row2=CorresCoordinate[i*NumOfImage+j][k].x2;
					CorresCoordinate[i*NumOfImage+j][k].col2=CorresCoordinate[i*NumOfImage+j][k].y2;
					CorresCoordinate[i*NumOfImage+j][k].x1=(CorresCoordinate[i*NumOfImage+j][k].x1-Height[i]/2)*cams[camfile[i].CamIndex-1].cellsize;
					CorresCoordinate[i*NumOfImage+j][k].y1=(CorresCoordinate[i*NumOfImage+j][k].y1-Width[i]/2)*cams[camfile[i].CamIndex-1].cellsize;
					swap=CorresCoordinate[i*NumOfImage+j][k].y1;
					CorresCoordinate[i*NumOfImage+j][k].y1=-CorresCoordinate[i*NumOfImage+j][k].x1;
					CorresCoordinate[i*NumOfImage+j][k].x1=swap;
					CorresCoordinate[i*NumOfImage+j][k].x1-=cams[camfile[i].CamIndex-1].xp;
					CorresCoordinate[i*NumOfImage+j][k].y1-=cams[camfile[i].CamIndex-1].yp;
					r=sqrt(pow(CorresCoordinate[i*NumOfImage+j][k].x1,2)+pow(CorresCoordinate[i*NumOfImage+j][k].y1,2));
					dx1=cams[camfile[i].CamIndex-1].k1*CorresCoordinate[i*NumOfImage+j][k].x1*pow(r,2)+cams[camfile[i].CamIndex-1].k2*CorresCoordinate[i*NumOfImage+j][k].x1*pow(r,4)+cams[camfile[i].CamIndex-1].k3*CorresCoordinate[i*NumOfImage+j][k].x1*pow(r,6)+cams[camfile[i].CamIndex-1].p1*(r*r+2*pow(CorresCoordinate[i*NumOfImage+j][k].x1,2))+2*cams[camfile[i].CamIndex-1].p2*CorresCoordinate[i*NumOfImage+j][k].x1*CorresCoordinate[i*NumOfImage+j][k].y1;
					dy1=cams[camfile[i].CamIndex-1].k1*CorresCoordinate[i*NumOfImage+j][k].y1*pow(r,2)+cams[camfile[i].CamIndex-1].k2*CorresCoordinate[i*NumOfImage+j][k].y1*pow(r,4)+cams[camfile[i].CamIndex-1].k3*CorresCoordinate[i*NumOfImage+j][k].y1*pow(r,6)+cams[camfile[i].CamIndex-1].p2*(r*r+2*pow(CorresCoordinate[i*NumOfImage+j][k].y1,2))+2*cams[camfile[i].CamIndex-1].p1*CorresCoordinate[i*NumOfImage+j][k].x1*CorresCoordinate[i*NumOfImage+j][k].y1;
					CorresCoordinate[i*NumOfImage+j][k].x1+=dx1;
					CorresCoordinate[i*NumOfImage+j][k].y1+=dy1;

					CorresCoordinate[i*NumOfImage+j][k].x2=(CorresCoordinate[i*NumOfImage+j][k].x2-Height[j]/2)*cams[camfile[j].CamIndex-1].cellsize;
					CorresCoordinate[i*NumOfImage+j][k].y2=(CorresCoordinate[i*NumOfImage+j][k].y2-Width[j]/2)*cams[camfile[j].CamIndex-1].cellsize;
					swap=CorresCoordinate[i*NumOfImage+j][k].y2;
					CorresCoordinate[i*NumOfImage+j][k].y2=-CorresCoordinate[i*NumOfImage+j][k].x2;
					CorresCoordinate[i*NumOfImage+j][k].x2=swap;
					CorresCoordinate[i*NumOfImage+j][k].x2-=cams[camfile[j].CamIndex-1].xp;
					CorresCoordinate[i*NumOfImage+j][k].y2-=cams[camfile[j].CamIndex-1].yp;
					r=sqrt(pow(CorresCoordinate[i*NumOfImage+j][k].x2,2)+pow(CorresCoordinate[i*NumOfImage+j][k].y2,2));
					dx2=cams[camfile[j].CamIndex-1].k1*CorresCoordinate[i*NumOfImage+j][k].x2*pow(r,2)+cams[camfile[j].CamIndex-1].k2*CorresCoordinate[i*NumOfImage+j][k].x2*pow(r,4)+cams[camfile[j].CamIndex-1].k3*CorresCoordinate[i*NumOfImage+j][k].x2*pow(r,6)+cams[camfile[j].CamIndex-1].p1*(r*r+2*pow(CorresCoordinate[i*NumOfImage+j][k].x2,2))+2*cams[camfile[j].CamIndex-1].p2*CorresCoordinate[i*NumOfImage+j][k].x2*CorresCoordinate[i*NumOfImage+j][k].y2;
					dy2=cams[camfile[j].CamIndex-1].k1*CorresCoordinate[i*NumOfImage+j][k].y2*pow(r,2)+cams[camfile[j].CamIndex-1].k2*CorresCoordinate[i*NumOfImage+j][k].y2*pow(r,4)+cams[camfile[j].CamIndex-1].k3*CorresCoordinate[i*NumOfImage+j][k].y2*pow(r,6)+cams[camfile[j].CamIndex-1].p2*(r*r+2*pow(CorresCoordinate[i*NumOfImage+j][k].y2,2))+2*cams[camfile[j].CamIndex-1].p1*CorresCoordinate[i*NumOfImage+j][k].x2*CorresCoordinate[i*NumOfImage+j][k].y2;
					CorresCoordinate[i*NumOfImage+j][k].x2+=dx2;
					CorresCoordinate[i*NumOfImage+j][k].y2+=dy2;
				}
			}
		}
	}
}
void ObjectSpacePoint(int indexi,int indexj,int indexk,int value,int NumOfImage,CorresPoint** CorresCoordinate,int* MatchNum)
{
	if(CorresCoordinate[indexi*NumOfImage+indexj][indexk].value==-1)
	{
		CorresCoordinate[indexi*NumOfImage+indexj][indexk].value=value;
		for(int i=0;i<NumOfImage;i++)
		{
			if(i!=indexi)
			{
				for(int k=0;k<MatchNum[i*NumOfImage+indexj];k++)
				{
					if(CorresCoordinate[i*NumOfImage+indexj][k].x1!=-10000||CorresCoordinate[i*NumOfImage+indexj][k].y1!=-10000||CorresCoordinate[i*NumOfImage+indexj][k].x2!=-10000||CorresCoordinate[i*NumOfImage+indexj][k].y2!=-10000)
					{
						if(CorresCoordinate[i*NumOfImage+indexj][k].index2==CorresCoordinate[indexi*NumOfImage+indexj][indexk].index2)
							ObjectSpacePoint(i,indexj,k,value,NumOfImage,CorresCoordinate,MatchNum);
					}
				}
			}
		}
		for(int i=0;i<NumOfImage;i++)
		{
			for(int k=0;k<MatchNum[indexj*NumOfImage+i];k++)
			{
				if(CorresCoordinate[indexj*NumOfImage+i][k].x1!=-10000||CorresCoordinate[indexj*NumOfImage+i][k].y1!=-10000||CorresCoordinate[indexj*NumOfImage+i][k].x2!=-10000||CorresCoordinate[indexj*NumOfImage+i][k].y2!=-10000)
				{
					if(CorresCoordinate[indexj*NumOfImage+i][k].index1==CorresCoordinate[indexi*NumOfImage+indexj][indexk].index2)
						ObjectSpacePoint(indexj,i,k,value,NumOfImage,CorresCoordinate,MatchNum);
				}
			}
		}
		for(int j=0;j<NumOfImage;j++)
		{
			if(j!=indexj)
			{
				for(int k=0;k<MatchNum[indexi*NumOfImage+j];k++)
				{
					if(CorresCoordinate[indexi*NumOfImage+j][k].x1!=-10000||CorresCoordinate[indexi*NumOfImage+j][k].y1!=-10000||CorresCoordinate[indexi*NumOfImage+j][k].x2!=-10000||CorresCoordinate[indexi*NumOfImage+j][k].y2!=-10000)
					{
						if(CorresCoordinate[indexi*NumOfImage+j][k].index1==CorresCoordinate[indexi*NumOfImage+indexj][indexk].index1)
							ObjectSpacePoint(indexi,j,k,value,NumOfImage,CorresCoordinate,MatchNum);
					}
				}
			}
		}
		for(int j=0;j<NumOfImage;j++)
		{
			for(int k=0;k<MatchNum[j*NumOfImage+indexi];k++)
			{
				if(CorresCoordinate[j*NumOfImage+indexi][k].x1!=-10000||CorresCoordinate[j*NumOfImage+indexi][k].y1!=-10000||CorresCoordinate[j*NumOfImage+indexi][k].x2!=-10000||CorresCoordinate[j*NumOfImage+indexi][k].y2!=-10000)
				{
					if(CorresCoordinate[j*NumOfImage+indexi][k].index2==CorresCoordinate[indexi*NumOfImage+indexj][indexk].index1)
						ObjectSpacePoint(j,indexi,k,value,NumOfImage,CorresCoordinate,MatchNum);
				}
			}
		}
	}
	else if(CorresCoordinate[indexi*NumOfImage+indexj][indexk].value==value)
		return;
	else
		printf("高桥君，怎么回事？\n");
}
void Purify10000(CorresPoint** CorresCoordinate,int* MatchNum,int* RealMatchNum,int NumOfImage)
{
	CorresPoint* pPurePoints;
	int countpt;
	for(int i=0;i<NumOfImage;i++)
	{
		for(int j=0;j<NumOfImage;j++)
		{
			if(RealMatchNum[i*NumOfImage+j]==0)
			{
				if(CorresCoordinate[i*NumOfImage+j])
					delete [] CorresCoordinate[i*NumOfImage+j];
				CorresCoordinate[i*NumOfImage+j]=NULL;
			}
			else
			{
				pPurePoints=new CorresPoint [RealMatchNum[i*NumOfImage+j]];
				countpt=0;
				for(int k=0;k<MatchNum[i*NumOfImage+j];k++)
				{
					if(CorresCoordinate[i*NumOfImage+j][k].x1!=-10000||CorresCoordinate[i*NumOfImage+j][k].y1!=-10000||CorresCoordinate[i*NumOfImage+j][k].x2!=-10000||CorresCoordinate[i*NumOfImage+j][k].y2!=-10000)
					{
						pPurePoints[countpt].x1=CorresCoordinate[i*NumOfImage+j][k].x1;
						pPurePoints[countpt].y1=CorresCoordinate[i*NumOfImage+j][k].y1;
						pPurePoints[countpt].x2=CorresCoordinate[i*NumOfImage+j][k].x2;
						pPurePoints[countpt].y2=CorresCoordinate[i*NumOfImage+j][k].y2;
						pPurePoints[countpt].col1=CorresCoordinate[i*NumOfImage+j][k].col1;
						pPurePoints[countpt].row1=CorresCoordinate[i*NumOfImage+j][k].row1;
						pPurePoints[countpt].col2=CorresCoordinate[i*NumOfImage+j][k].col2;
						pPurePoints[countpt].row2=CorresCoordinate[i*NumOfImage+j][k].row2;
						pPurePoints[countpt].index1=CorresCoordinate[i*NumOfImage+j][k].index1;
						pPurePoints[countpt].index2=CorresCoordinate[i*NumOfImage+j][k].index2;
						pPurePoints[countpt].value=CorresCoordinate[i*NumOfImage+j][k].value;
						countpt++;
					}
				}
				if(CorresCoordinate[i*NumOfImage+j])
					delete [] CorresCoordinate[i*NumOfImage+j];
				CorresCoordinate[i*NumOfImage+j]=pPurePoints;
				if(countpt!=RealMatchNum[i*NumOfImage+j])
				{
					printf("不对呀！\n");
				}
			}
		}
	}
}